import (
    "th.um"
    "canvas.um"

    "delaunay.um"
)

type (
    Poly = struct {
        vert: []int
        isHole: bool
    }

    Triangle = struct {
        vert: [3]int
    }

    PointSet = map[int]bool

    Editor* = struct {
        cmd: int

        pts: []th.Vf2
        polys: []Poly
        tris: []Triangle
        constraints: PointSet

        selectedPt: int
        curPoly: Poly

        cam: th.Transform

        statusMsg: str
    }
)

const (
    CMD_ENTER_BOUNDARY* = 0
    CMD_ENTER_HOLE*
    CMD_ENTER_POINTS*
    CMD_ENTER_CONSTRAINTS*
    CMD_EDIT_POINT*
    CMD_DELETE_POINT*
    CMD_CALCULATE*
    CMD_CLEAR*  
)

const (
    POINT_SIZE = 10
    LINE_WIDTH = 3
)

fn inverse(t: th.Transform): th.Transform {
    return {p: {-t.p.x / t.s.x, -t.p.y / t.s.y}, s: {1.0 / t.s.x, 1.0 / t.s.y}}
}

fn (poly: ^Poly) reverse() {
    for i, j := 0, len(poly.vert) - 1; i < j; i++ {
        poly.vert[i], poly.vert[j] = poly.vert[j], poly.vert[i]
        j--
    }
}

fn (ed: ^Editor) isClockwise(poly: Poly): bool {
    sum := 0.0
    for i, pt1 := 0, ed.pts[poly.vert[len(poly.vert) - 1]]; i < len(poly.vert); i++ {
        pt2 := ed.pts[poly.vert[i]]
        sum += (pt2.x - pt1.x) * (pt2.y + pt1.y)
        pt1 = pt2
    }
    return sum > 0.0
}

fn (ed: ^Editor) findPoint(pos: th.Vf2): int {
    for i, pt in ed.pts {
        if fabs((pos.x - pt.x) * ed.cam.s.x) < POINT_SIZE && fabs((pos.y - pt.y) * ed.cam.s.y) < POINT_SIZE {
            return i
        }
    }
    return -1
}

fn (ed: ^Editor) deleteSelectedPoint() {
    // Detect polygon containing the point, decrement other point indices
    polyToDelete := -1
    for polyIndex, poly in ed.polys {
        for vertIndex, vert in poly.vert {
            if vert == ed.selectedPt {
                polyToDelete = polyIndex
                break
            } else if vert > ed.selectedPt {
                poly.vert[vertIndex]--
            }
        }
    }

    // Delete polygon containing the point
    if polyToDelete >= 0 {
        ed.polys = delete(ed.polys, polyToDelete)
    }

    // Delete constraint associated with the point, decrement other point indices
    ed.constraints[ed.selectedPt] = false
    for constr, exists in ed.constraints {
        if exists && constr > ed.selectedPt {
            ed.constraints[constr] = false
            ed.constraints[constr - 1] = true
        }
    }

    // Delete point
    ed.pts = delete(ed.pts, ed.selectedPt)
    ed.selectedPt = -1
}

fn (ed: ^Editor) triangulate() {
    boundaries := []delaunay.Poly{}
    for i, poly in ed.polys {
        boundaries = append(boundaries, poly.vert)  
    }   

    triangles, ok := delaunay.triangulate(ed.pts, boundaries)
    ed.statusMsg = ok ? "" : "Bad boundary"

    ed.tris = []Triangle{}
    for tri, exists in triangles {
        if exists {
            ed.tris = append(ed.tris, Triangle{tri})          
        }
    }
}

fn (ed: ^Editor) init*() {
    ed.cam = th.mkTransform({0, 0}, {1, -1})
    ed.cmd = CMD_EDIT_POINT
}

fn (ed: ^Editor) endCmd*() {
    switch ed.cmd {
        case CMD_DELETE_POINT:
            if ed.selectedPt >= 0 {
                ed.deleteSelectedPoint()
            }

        case CMD_ENTER_BOUNDARY, CMD_ENTER_HOLE:
            if len(ed.curPoly.vert) > 2 {
                if ed.curPoly.isHole != ed.isClockwise(ed.curPoly) {
                    ed.curPoly.reverse()
                }
                ed.polys = append(ed.polys, ed.curPoly)
            }
    }

    ed.selectedPt = -1
    ed.curPoly = {isHole: ed.cmd == CMD_ENTER_HOLE}
    ed.statusMsg = ""
}

fn (ed: ^Editor) startCmd*(cmd: int) {
    ed.endCmd()
    ed.cmd = cmd
    
    switch ed.cmd {
        case CMD_ENTER_BOUNDARY, CMD_ENTER_HOLE:
            ed.curPoly = {isHole: ed.cmd == CMD_ENTER_HOLE}

        case CMD_CALCULATE:
            ed.triangulate()

        case CMD_CLEAR:
            ed^ = Editor{}
            ed.init() 
    } 
}

fn (ed: ^Editor) processLeftClick*(pos: th.Vf2) {
    worldPos := pos.transformed(inverse(ed.cam))

    switch ed.cmd {
        case CMD_EDIT_POINT, CMD_DELETE_POINT: 
            ed.selectedPt = ed.findPoint(worldPos)

        case CMD_ENTER_POINTS:
            ed.pts = append(ed.pts, worldPos)

        case CMD_ENTER_CONSTRAINTS:
            if existingPt := ed.findPoint(worldPos); existingPt >= 0 {
                ed.constraints[existingPt] = true
            } else {            
                ed.pts = append(ed.pts, worldPos)
                ed.constraints[len(ed.pts) - 1] = true
            }            

        case CMD_ENTER_BOUNDARY, CMD_ENTER_HOLE:
            if existingPt := ed.findPoint(worldPos); existingPt >= 0 {
                ed.curPoly.vert = append(ed.curPoly.vert, existingPt)
            } else {            
                ed.pts = append(ed.pts, worldPos)
                ed.curPoly.vert = append(ed.curPoly.vert, len(ed.pts) - 1)
            }
    }
}

fn (ed: ^Editor) processRightClick*() {
    ed.endCmd()
}

fn (ed: ^Editor) processLeftDrag*(pos: th.Vf2) {
    if ed.cmd == CMD_EDIT_POINT && ed.selectedPt >= 0 {
        worldPos := pos.transformed(inverse(ed.cam))        
        ed.pts[ed.selectedPt] = worldPos     
    }
}

fn (ed: ^Editor) processMidDrag*(delta: th.Vf2) {
    ed.cam.p = ed.cam.p.add(delta)
}

fn (ed: ^Editor) processWheel*(pos: th.Vf2, scroll: real32) {
    scale := (1 + 0.1 * scroll) * ed.cam.s.x
    if scale > 10.0 {scale = 10.0}
    if scale <  0.1 {scale =  0.1}

    ed.cam.p = ed.cam.p.sub(pos.transformed(inverse(ed.cam)).mul({scale - ed.cam.s.x, -scale - ed.cam.s.y}))
    ed.cam.s = {scale, -scale}
}

fn (ed: ^Editor) drawBackground(windowSize: th.Vf2) {
    canvas.drawRect(0x222222FF, {-10, -10, windowSize.x + 20, windowSize.y + 20})
}

fn (ed: ^Editor) drawPolygons() {
    for _, poly in ed.polys {
        clr := poly.isHole ? th.blue : th.white

        for i, pt1 := 0, ed.pts[poly.vert[len(poly.vert) - 1]]; i < len(poly.vert); i++ {
            pt2 := ed.pts[poly.vert[i]]
            canvas.drawLine(clr, pt1.transformed(ed.cam), pt2.transformed(ed.cam), LINE_WIDTH)
            pt1 = pt2
        }
    }

    // Draw current polygon
    if len(ed.curPoly.vert) > 0 {
        for i, pt1 := 0, ed.pts[ed.curPoly.vert[0]]; i < len(ed.curPoly.vert) - 1; i++ {
            pt2 := ed.pts[ed.curPoly.vert[i + 1]]
            canvas.drawLine(th.red, pt1.transformed(ed.cam), pt2.transformed(ed.cam), LINE_WIDTH)
            pt1 = pt2
        }
    }   
}

fn (ed: ^Editor) drawPoints() {
    for i, pt in ed.pts {
        clr := i == ed.selectedPt ? th.red : th.green
        screenPt := pt.transformed(ed.cam)
        canvas.drawQuad(clr, {
            screenPt.add({-POINT_SIZE / 2, -POINT_SIZE / 2}), 
            screenPt.add({ POINT_SIZE / 2, -POINT_SIZE / 2}), 
            screenPt.add({ POINT_SIZE / 2,  POINT_SIZE / 2}), 
            screenPt.add({-POINT_SIZE / 2,  POINT_SIZE / 2})
        })
    }
}

fn (ed: ^Editor) drawTriangles() {
    for _, tri in ed.tris {
        screenPt := [3]th.Vf2{
            ed.pts[tri.vert[0]].transformed(ed.cam),
            ed.pts[tri.vert[1]].transformed(ed.cam),
            ed.pts[tri.vert[2]].transformed(ed.cam)
        }
        
        canvas.drawQuad(0x555555FF, {screenPt[0], screenPt[1], screenPt[2], screenPt[2]})
        canvas.drawLine(th.white, screenPt[0], screenPt[1], 1)
        canvas.drawLine(th.white, screenPt[1], screenPt[2], 1)
        canvas.drawLine(th.white, screenPt[2], screenPt[0], 1)
    }
}

fn (ed: ^Editor) drawConstraints() {
    for constr, exists in ed.constraints {
        if !exists {continue}

        screenPt := ed.pts[constr].transformed(ed.cam)
        canvas.drawQuad(th.magenta, {
            screenPt, 
            screenPt.add({-POINT_SIZE, POINT_SIZE * 2}), 
            screenPt.add({ POINT_SIZE, POINT_SIZE * 2}), 
            screenPt.add({ POINT_SIZE, POINT_SIZE * 2})
        })        
    }
}

fn (ed: ^Editor) drawScaleBar(windowSize: th.Vf2) {
    worldLen := 100
    if ed.cam.s.x > 5.0 {
        worldLen = 10
    } else if ed.cam.s.x < 0.2 {
        worldLen = 1000
    }
    screenLen := worldLen * ed.cam.s.x

    startPt := th.Vf2{windowSize.x - screenLen - 50, windowSize.y - 50}
    endPt := startPt.add({screenLen, 0})

    canvas.drawLine(th.white, startPt, endPt, 1)

    text := sprintf("%d mm", worldLen)
    textPos := startPt.add({0, -20})

    canvas.drawText(text, textPos, th.white, 2)
}

fn (ed: ^Editor) draw*(windowSize: th.Vf2) {
    ed.drawBackground(windowSize)   

    if ed.cmd == CMD_CALCULATE {
        ed.drawTriangles()
    } else {
        ed.drawPolygons()
        ed.drawPoints()
    }

    ed.drawConstraints()
    ed.drawScaleBar(windowSize)
}

